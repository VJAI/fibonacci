@use 'sass:string';
@use 'variables' as fibVars;

// Credits: https://github.com/alyssais/Sass-Web-Fonts
@function wf-str-replace($string, $find, $replace, $all: true) {
  $index: str-index($string, $find);
  @if $index {
    $before: str-slice($string, 1, $index - 1);
    $after: str-slice($string, $index + str-length($find), str-length($string));
    $string: $before + $replace + $after;

    @if $all and not str-index($find, $replace) {
      $string: wf-str-replace($string, $find, $replace);
    }
  }
  @return $string;
}

@function wf-url-encode($string) {
  $replacements: (
          "!": "%21",
          "#": "%23",
          "$": "%24",
          "&": "%26",
          "'": "%27",
          "(": "%28",
          ")": "%29",
          "*": "%2A",
          "+": "%2B",
          ",": "%2C",
          "/": "%2F",
          ":": "%3A",
          ";": "%3B",
          "=": "%3D",
          "?": "%3F",
          "@": "%40",
          "[": "%5B",
          "]": "%5D",
          " ": "%20"
  );

  @each $from, $to in $replacements {
    $string: wf-str-replace($string, $from, $to);
  }

  @return $string;
}

@function wf-implode($list, $separator: ',') {
  $string: '';
  @for $i from 1 through length($list) {
    $el: nth($list, $i);
    $string: $string + $el;
    @if ($i < length($list)) {
      $string: $string + $separator;
    }
  }
  @return $string;
}

@function wf-serialize($fonts) {
  @if type-of($fonts) == 'list' or type-of($fonts) == 'arglist' {
    $serialized: ();
    @each $font in $fonts {
      $serialized: append($serialized, wf-serialize($font));
    }
    @return wf-implode($serialized, '|');
  }

  @if type-of($fonts) == 'map' {
    $serialized: ();
    @each $family, $variants in $fonts {
      $variants: wf-implode($variants, ',');
      $variants: wf-str-replace($variants, ' ', '');
      $serialized: append($serialized, "#{$family}:#{$variants}");
    }
    @return wf-serialize($serialized);
  }

  @if type-of($fonts) == 'string' {
    @return wf-url-encode($fonts);
  }

  @warn "Unsupported font type: #{type-of($fonts)}";
}

@function wf-protocol() {
  $web-fonts-protocol: '' !global !default;
  $protocol: $web-fonts-protocol;
  @if str-length($protocol) > 0 {
    $protocol: $protocol + ':';
  }
  @return $protocol;
}

@function wf-query-string-encode($params) {
  $query-string: "";
  @each $key, $value in $params {
    $query-string: $query-string + wf-url-encode($key) + "=";
    $query-string: $query-string + wf-url-encode($value) + "&";
  }
  // remove trailing ampersand
  $query-string: str-slice($query-string, 1, -2);
  @return $query-string;
}

@function wf-params-string($fonts) {
  $web-fonts-params: () !global !default;
  $params: map-merge((family: wf-serialize($fonts)), $web-fonts-params);
  @return wf-query-string-encode($params);
}

@function web-fonts-url($fonts...) {
  $protocol: wf-protocol();
  $query-string: wf-params-string($fonts);
  $url: "#{$protocol}//fonts.googleapis.com/css?#{$query-string}";
  @return $url;
}

/// Loads passed fonts with variations from google.
///
/// @param {Map} $fonts
///   Fonts and variations dictionary.
@mixin load_google_font($fonts) {
  $url: web-fonts-url($fonts);
  @import url($url);
}

// Horizontal centering.
@mixin horizontal-center {
  margin: {
    left: auto;
    right: auto;
  }
}

/// Creates flexbox container with passed configuration.
///
/// @param {boolean} $inline
///   Passing `true` creates inline flex container else normal flex container.
/// @param {boolean} $column
///   Passing `true` arranges flex items in column else in row.
/// @param {boolean} $center
///   Passing `true` centers the flex items vertically and horizontally.
/// @param {boolean} $hor
///   Passing `true` centers flex items horizontally.
/// @param {boolean} $ver
///   Passing `true` centers flex items vertically.
/// @param {boolean} $wrap
///   Passing `true` wrap the items.
/// @param {string} $justify
///   Equivalent to flex container's `justify-content` property.
/// @param {string} $align
///   Equivalent to flex container's `align-items` property.
@mixin flex_init(
  $inline: false,
  $column: false,
  $center: false,
  $hor: false,
  $ver: false,
  $wrap: false,
  $justify: null,
  $align: null
) {
  @if $inline {
    display: inline-flex;
  } @else {
    display: flex;
  }

  @if $column {
    flex-direction: column;
  }

  @if $wrap {
    flex-wrap: wrap;
  }

  @if $center == true or ($column == false and $hor == true) or ($column == true and $ver == true) {
    justify-content: center;
  }

  @if $center == true or ($column == false and $ver == true) or ($column == true and $hor == true) {
    align-items: center;
  }

  @if $justify {
    justify-content: string.unquote($justify);
  }

  @if $align {
    align-items: string.unquote($align);
  }
}

/// Updates flexbox container.
///
/// @param {boolean} $column
///   Passing `true` arranges flex items in column and `false` in row.
/// @param {boolean} $wrap
///   Passing `true` wrap the items and `false` unwraps them.
/// @param {string} $justify
///   Equivalent to flex container's `justify-content` property.
/// @param {string} $align
///   Equivalent to flex container's `align-items` property.
@mixin flex_update(
  $column: null,
  $wrap: null,
  $justify: null,
  $align: null
) {
  @if $column == true {
    flex-direction: column;
  } @else if $column == false {
    flex-direction: row;
  }

  @if $wrap == true {
    flex-wrap: wrap;
  } @else if $wrap == false {
    flex-wrap: nowrap;
  }

  @if $justify {
    justify-content: string.unquote($justify);
  }

  @if $align {
    align-items: string.unquote($align);
  }
}

/// Sets a colored noisy background using an image.
/// @param {string} $bg
///   The background color.
@mixin noisy_bg($bg: fibVars.$white) {
  background: url('#{fibVars.$assets-path}/background.png') $bg;
}

/// Sets background, box-shadow and border radius.
/// @param {string} $bg
///   The background color.
@mixin config_container($bg) {
  @include noisy_bg($bg);
  border-radius: fibVars.$border-radius;
  box-shadow: fibVars.$box-shadow;
}

/// Creates an inset text shadow.
@mixin inset_text_shadow() {
  color: transparent;
  text-shadow: 2px 2px 3px rgba(255, 255, 255, 0.5);
  -webkit-background-clip: text;
  -moz-background-clip: text;
  background-clip: text;
}

/// Creates container with no margin or padding.
@mixin no_spacing {
  margin: 0;
  padding: 0;
}

@mixin set_hor_margin($value) {
  margin-left: $value;
  margin-right: $value;
}

@mixin set_shadow_radius {
  border-radius: fibVars.$border-radius;
  box-shadow: fibVars.$box-shadow;
}

@mixin no_shadow_radius {
  border-radius: 0;
  box-shadow: none;
}